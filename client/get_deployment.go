package client

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
)

//Deployments is a collection of DeploymentResponse
type Deployments []DeploymentResponse

//DeploymentResponse type is autogenerated with https://mholt.github.io/json-to-go/
type DeploymentResponse struct {
	ID              int             `json:"id"`
	TrackingID      int             `json:"trackingId"`
	State           DeploymentState `json:"state"`
	DeploymentDate  int64           `json:"deploymentDate"`
	AppServerName   string          `json:"appServerName"`
	AppServerID     int             `json:"appServerId"`
	AppsWithVersion []struct {
		ApplicationName string `json:"applicationName"`
		Version         string `json:"version"`
	} `json:"appsWithVersion"`
	DeploymentParameters []interface{} `json:"deploymentParameters"`
	EnvironmentName      string        `json:"environmentName"`
	ReleaseName          string        `json:"releaseName"`
	RuntimeName          string        `json:"runtimeName"`
	RequestUser          string        `json:"requestUser"`
	ConfirmUser          string        `json:"confirmUser"`
	CancelUser           interface{}   `json:"cancelUser"`
	NodeJobs             []interface{} `json:"nodeJobs"`
	CancleUser           interface{}   `json:"cancleUser"`
}

//sort.Interface
func (slice Deployments) Len() int {
	return len(slice)
}

func (slice Deployments) Less(i, j int) bool {
	return slice[i].AppServerName < slice[j].AppServerName
}

func (slice Deployments) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

//CommandOptionsGetDeployment used for the command options (flags)
type CommandOptionsGetDeployment struct {
	AppName         []string          `json:"appName"`
	AppServer       []string          `json:"appServerName"`
	DeploymentState []DeploymentState `json:"deploymentState"`
	Environment     []string          `json:"environmentName"`
	TrackingID      int               `json:"trackingId"`
	OnlyLatest      bool              `json:"onlyLatest"`
	Filter          []DeploymentFilter
	ID              []int //deployment id
}

// DeploymentFilter is a Liima deployment filter
type DeploymentFilter struct {
	Name string               `json:"name"`
	Comp DeploymentFilterComp `json:"comp"`
	Val  interface{}          `json:"val"`
}

// DeploymentFilterComp is a Liima deployment filter comperator
type DeploymentFilterComp string

//Enumeration of deployment comperators
const (
	Eq  DeploymentFilterComp = "eq"
	Lt  DeploymentFilterComp = "lt"
	Lte DeploymentFilterComp = "lte"
	Gt  DeploymentFilterComp = "gt"
	Gte DeploymentFilterComp = "gte"
	Neq DeploymentFilterComp = "neq"
)

// DeploymentState is the state of a Liima deployment
type DeploymentState string

//Enumeration of deployment state
const (
	DeploymentStateSuccess        DeploymentState = "success"
	DeploymentStateFailed         DeploymentState = "failed"
	DeploymentStateCanceled       DeploymentState = "canceled"
	DeploymentStateRejected       DeploymentState = "rejected"
	DeploymentStateReadyForDeploy DeploymentState = "ready_for_deploy"
	DeploymentStatePreDeploy      DeploymentState = "pre_deploy"
	DeploymentStateProgress       DeploymentState = "progress"
	DeploymentStateSimulating     DeploymentState = "simulating"
	DeploymentStateDelayed        DeploymentState = "delayed"
	DeploymentStateScheduled      DeploymentState = "scheduled"
	DeploymentStateRequested      DeploymentState = "requested"
)

//GetDeployment return the deployment from the client
func GetDeployment(cli *Cli, commandOptions *CommandOptionsGetDeployment) (Deployments, error) {
	var filter []DeploymentFilter
	var err error
	resturl := "resources/deployments/filter?filters="
	deployments := Deployments{}

	if len(commandOptions.Filter) != 0 {
		filter = commandOptions.Filter
	} else {
		filter = buildFilterFromOptions(commandOptions)
	}

	b, err := json.Marshal(filter)
	if err != nil {
		return deployments, fmt.Errorf("Could not build filter: %v", err)
	}
	//Build URL
	resturl += url.QueryEscape(string(b))

	//Call rest client
	if err := cli.Client.DoRequest(http.MethodGet, resturl, nil, &deployments); err != nil {
		return deployments, err
	}

	return deployments, nil
}

func buildFilterFromOptions(commandOptions *CommandOptionsGetDeployment) []DeploymentFilter {
	filters := []DeploymentFilter{}
	for _, val := range commandOptions.AppName {
		filters = append(filters, createEqFilter("Application", val))
	}
	for _, val := range commandOptions.AppServer {
		filters = append(filters, createEqFilter("Application server", val))
	}
	for _, val := range commandOptions.DeploymentState {
		filters = append(filters, createEqFilter("State", val))
	}
	for _, val := range commandOptions.Environment {
		filters = append(filters, createEqFilter("Environment", val))
	}
	for _, val := range commandOptions.ID {
		filters = append(filters, createEqFilter("Id", val))
	}
	// ignore defaults form cmd
	if commandOptions.OnlyLatest != false {
		filters = append(filters, createEqFilter("Latest deployment job for App Server and Env", commandOptions.OnlyLatest))
	}
	if commandOptions.TrackingID != -1 {
		filters = append(filters, createEqFilter("Tracking Id", commandOptions.TrackingID))
	}
	return filters
}

func createEqFilter(name string, value interface{}) DeploymentFilter {
	return DeploymentFilter{
		Name: name,
		Comp: Eq,
		Val:  value,
	}
}
